{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PolyAny","text":"<p> A Python package for algebraic manipulation of multivariate polynomials. </p> <p> </p> <p>This package is in alpha stage</p> <p>Some breaking changes may occur.</p>"},{"location":"#overview","title":"Overview","text":"<p>PolyAny provides a flexible framework for representing and manipulating multivariate polynomials using structured, non-symbolic representations.</p> <p>Unlike symbolic engines, PolyAny operates directly on the algebraic structure of polynomials (coefficients and exponents), enabling integration with numerical libraries and efficient structural transformations.</p>"},{"location":"#features-planned","title":"Features (planned)","text":"<ul> <li>Polynomial creation from multiple formats (list, tuples, NumPy arrays, quadratic forms, ...)</li> <li>Support for multivariate expressions</li> <li>Algebraic operations: addition, multiplication, truncation, homogenization, ...</li> <li>Polynomial exporting into LaTeX code</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is open-source and licensed under the BSD-3-Clause.</p>"},{"location":"#contributors","title":"Contributors","text":"<p>PolyAny is maintained by the ROLMIP developers:</p> <ul> <li> <p> Cristiano Agulhari</p> <p> agulhari@utfpr.edu.br  /agulhari  ORCID</p> </li> <li> <p> Esdras Battosti</p> <p> esdras.2019@alunos.utfpr.edu.br  /ximiraxelo  /esdrasbattosti  ORCID</p> </li> </ul>"},{"location":"#about","title":"About","text":"<p>This repository is part of the early foundation of RolmiPy, a Python implementation of ROLMIP.</p>"},{"location":"api/","title":"API reference","text":"<p>Documentation under construction</p>"},{"location":"api/#polyany.polynomial.Polynomial","title":"Polynomial","text":"<pre><code>Polynomial(exponents: ArrayLike, coefficients: ArrayLike)\n</code></pre> <p>A multivariate polynomial class.</p> <p>Represents a multivariate polynomial in the form:</p> <p>P(X) = \u2211 c_i * x_1^e_i1 * x_2^e_i2 * ... * x_n^e_in</p> <p>where <code>c_i</code> are the coefficients and <code>e_ji</code> are the exponents of each monomial.</p> PARAMETER DESCRIPTION <code>exponents</code> <p>A nested sequence or a NumPy 2D-array with shape (n_monomials, n_vars), where each row contains the exponents of one monomial. The order of variables is assumed to be increasing, i.e., [x_1, x_2, ..., x_n].</p> <p> TYPE: <code>ArrayLike</code> </p> <code>coefficients</code> <p>A sequence or a NumPy 1D-array with shape (n_monomials,). Containing the corresponding scalar multipliers of each monomial.</p> <p> TYPE: <code>ArrayLike</code> </p> ATTRIBUTE DESCRIPTION <code>n_vars</code> <p>Number of variables in the polynomial.</p> <p> TYPE: <code>int</code> </p> <code>degree</code> <p>Total degree of the polynomial.</p> <p> TYPE: <code>int</code> </p> <code>exponents</code> <p>A NumPy 2D-array representing the exponents of the polynomial.</p> <p> TYPE: <code>ndarray</code> </p> <code>coefficients</code> <p>A NumPy 1D-array with the corresponding coefficients.</p> <p> TYPE: <code>ndarray</code> </p> RAISES DESCRIPTION <code>TypeError</code> <ul> <li>If the input exponents cannot be safely converted to a NumPy 2D-array of integers.</li> <li>If the input coefficients cannot be safely converted to a NumPy 1D-array of floats.</li> </ul> <code>ValueError</code> <ul> <li>If the number of exponents does not match the number of coefficients.</li> <li>If the input arrays dimensions are inconsistent.</li> <li>If the input exponents rows are not unique.</li> <li>If any input exponent entry is negative.</li> </ul> Notes <p>The current implementation allows coefficients to be complex numbers, but complex polynomials are not yet officially supported and may produce unexpected behavior.</p> <p>Although attributes are publicly accessible, modifying them directly may lead to bugs and unexpected behavior.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from polyany import Polynomial\n</code></pre> <p>Create the polynomial: <code>5*x_1**2*x_2*x_3**4*x_5 + 3*x_1*x_2 + 4*x_4**4*x_5**3</code></p> <pre><code>&gt;&gt;&gt; exponents = [[1, 1, 0, 0, 0],\n...              [0, 0, 0, 4, 3],\n...              [2, 1, 4, 0, 1]]\n&gt;&gt;&gt; coefficients = [3, 4, 5]\n&gt;&gt;&gt; Polynomial(exponents, coefficients)\n3*x_1*x_2 + 4*x_4^4*x_5^3 + 5*x_1^2*x_2*x_3^4*x_5\n</code></pre>"},{"location":"api/#polyany.polynomial.Polynomial.__add__","title":"__add__","text":"<pre><code>__add__(other: object) -&gt; Polynomial\n</code></pre> <p>Addition with another polynomial or scalar</p> PARAMETER DESCRIPTION <code>other</code> <p>The value to be added. A scalar can be an int, float, or NumPy scalars.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A new polynomial representing the sum.</p>"},{"location":"api/#polyany.polynomial.Polynomial.__call__","title":"__call__","text":"<pre><code>__call__(point: ArrayLike) -&gt; float64\n</code></pre> <p>Evaluate the polynomial at a given point</p> PARAMETER DESCRIPTION <code>point</code> <p>A point with <code>n_vars</code> components.</p> <p> TYPE: <code>ArrayLike</code> </p> RETURNS DESCRIPTION <code>float64</code> <p>The result of evaluating the polynomial at <code>point</code>.</p> RAISES DESCRIPTION <code>TypeError</code> <ul> <li>If <code>point</code> cannot be safely converted to a NumPy 1D-array of floats.</li> </ul> <code>ValueError</code> <ul> <li>If <code>point</code> does not have exactly one dimension.</li> <li>If <code>point</code> does not have <code>n_vars</code> components.</li> </ul> <p>Examples:</p> <p>For univariate polynomials:</p> <pre><code>&gt;&gt;&gt; poly = Polynomial.univariate([1, 2, 3])\n&gt;&gt;&gt; poly([0])\nnp.float64(1.0)\n&gt;&gt;&gt; poly([2])\nnp.float64(17.0)\n</code></pre> <p>For multivariate polynomials:</p> <pre><code>&gt;&gt;&gt; exponents = [[0, 0],\n...              [1, 0],\n...              [0, 1],\n...              [1, 1]]\n&gt;&gt;&gt; coefficients = [9, 7, 5, 3]\n&gt;&gt;&gt; poly = Polynomial(exponents, coefficients)\n&gt;&gt;&gt; poly([0, 0])\nnp.float64(9.0)\n&gt;&gt;&gt; poly([1, 2])\nnp.float64(32.0)\n</code></pre>"},{"location":"api/#polyany.polynomial.Polynomial.__lshift__","title":"__lshift__","text":"<pre><code>__lshift__(other: int) -&gt; Polynomial\n</code></pre> <p>Removes empty variables of the Polynomial.</p> <p>A shorthand for <code>Polynomial.shift(k)</code> with <code>k &lt; 0</code> using the left shift operator (<code>&lt;&lt;</code>). For more details, see the <code>Polynomial.shift()</code> method.</p> PARAMETER DESCRIPTION <code>other</code> <p>The shift count. Must be a non-negative integer.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A new polynomial with shifted variables.</p> RAISES DESCRIPTION <code>ValueError</code> <ul> <li>If the shift count (<code>other</code>) is negative.</li> </ul>"},{"location":"api/#polyany.polynomial.Polynomial.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: object) -&gt; Polynomial\n</code></pre> <p>Multiplication with another polynomial or scalar</p> PARAMETER DESCRIPTION <code>other</code> <p>The value to be multiplied. A scalar can be an int, float, or NumPy scalars.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A new polynomial representing the multiplication.</p>"},{"location":"api/#polyany.polynomial.Polynomial.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Polynomial\n</code></pre> <p>The negation of the polynomial.</p> <p>All coefficients are multiplied by <code>-1</code>. The exponents remain unchanged.</p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A new polynomial with negated coefficients.</p>"},{"location":"api/#polyany.polynomial.Polynomial.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(other: int) -&gt; Polynomial\n</code></pre> <p>Adds extra variables to the Polynomial.</p> <p>A shorthand for <code>Polynomial.shift(k)</code> with <code>k &gt; 0</code> using the right shift operator (<code>&gt;&gt;</code>). For more details, see the <code>Polynomial.shift()</code> method.</p> PARAMETER DESCRIPTION <code>other</code> <p>The shift count. Must be a non-negative integer.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A new polynomial with shifted variables.</p> RAISES DESCRIPTION <code>ValueError</code> <ul> <li>If the shift count (<code>other</code>) is negative.</li> </ul>"},{"location":"api/#polyany.polynomial.Polynomial.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Algebraic) -&gt; Polynomial\n</code></pre> <p>Subtraction with another polynomial or scalar</p> PARAMETER DESCRIPTION <code>other</code> <p>The value to be subtracted. A scalar can be an int, float, or NumPy scalars.</p> <p> TYPE: <code>Algebraic</code> </p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A new polynomial representing the difference.</p>"},{"location":"api/#polyany.polynomial.Polynomial.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Scalar) -&gt; Polynomial\n</code></pre> <p>Division with a scalar</p> PARAMETER DESCRIPTION <code>other</code> <p>The value to divide the polynomial by.</p> <p> TYPE: <code>Scalar</code> </p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A new polynomial representing the division.</p> RAISES DESCRIPTION <code>ZeroDivisionError</code> <ul> <li>If <code>other</code> is a builtin scalar and equal to zero.</li> </ul> <code>FloatingPointError</code> <ul> <li>If <code>other</code> is a NumPy scalar and equal to zero.</li> </ul> Notes <p>Currently, division can only be performed between polynomials and scalars.</p>"},{"location":"api/#polyany.polynomial.Polynomial.partial","title":"partial","text":"<pre><code>partial(var_index: int) -&gt; Polynomial\n</code></pre> <p>Partial derivative of a polynomial</p> <p>Computes the partial derivative of the polynomial with respect to the variable indexed by <code>var_index</code>.</p> PARAMETER DESCRIPTION <code>var_index</code> <p>The variable index to perform the partial derivative (zero-based).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Polynomial</code> <p>The resulting polynomial after differentiation.</p> RAISES DESCRIPTION <code>TypeError</code> <ul> <li>If <code>var_index</code> is not an int.</li> </ul> <code>ValueError</code> <ul> <li>If <code>var_index</code> is outside the valid range [0, <code>n_vars</code> - 1].</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = Polynomial([[1, 0], [2, 1]], [3, 5])\n&gt;&gt;&gt; poly\n3*x_1 + 5*x_1^2*x_2\n&gt;&gt;&gt; poly.partial(0)\n3 + 10*x_1*x_2\n&gt;&gt;&gt; poly.partial(1)\n5*x_1^2\n</code></pre>"},{"location":"api/#polyany.polynomial.Polynomial.prune","title":"prune","text":"<pre><code>prune() -&gt; Polynomial\n</code></pre> <p>Prune the empty monomials of a polynomial.</p> <p>Removes all monomials whose associated coefficients are exactly zero.</p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A pruned polynomial, containing only monomials with non-zero coefficients.</p> Notes <p>If all coefficients are zero, a <code>zeros</code> polynomial with the same number of variables is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = Polynomial.univariate([1, 0, 0, 1])\n&gt;&gt;&gt; poly.exponents\narray([[0],\n       [1],\n       [2],\n       [3]])\n</code></pre> <p>This polynomial has four terms, but only the first and last have a non-zero coefficient.</p> <pre><code>&gt;&gt;&gt; pruned = poly.prune()\n&gt;&gt;&gt; pruned.exponents\narray([[0],\n       [3]])\n</code></pre> <p>The result keeps only the non-empty monomials, discarding all others.</p>"},{"location":"api/#polyany.polynomial.Polynomial.quadratic_form","title":"quadratic_form  <code>classmethod</code>","text":"<pre><code>quadratic_form(matrix: ArrayLike) -&gt; Polynomial\n</code></pre> <p>Creates a quadratic form from its associated symmetric matrix</p> PARAMETER DESCRIPTION <code>matrix</code> <p>A nested sequence or a NumPy 2D array of shape (<code>n_vars</code>, <code>n_vars</code>) that representing the symmetric matrix associated with the quadratic form.</p> <p> TYPE: <code>ArrayLike</code> </p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A second-degree homogeneous multivariate polynomial, i.e, a quadratic form.</p> RAISES DESCRIPTION <code>TypeError</code> <ul> <li>If <code>matrix</code> is not safe-convertible to a NumPy 2D array with float entries.</li> </ul> <code>ValueError</code> <ul> <li>If <code>matrix</code> does not have 2 dimensions.</li> <li>If <code>matrix</code> is not square.</li> </ul> WARNS DESCRIPTION <code>UserWarning</code> <ul> <li>If <code>matrix</code>is not symmetric.</li> </ul> Notes <p>If <code>matrix</code> is not symmetric, its symmetric part is used instead, computed as <code>symmetric_part = (matrix + matrix.T) / 2</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; matrix = [[5, 3, 2],\n...           [3, 1, 0],\n...           [2, 0, 7]]\n&gt;&gt;&gt; Polynomial.quadratic_form(matrix)\n5*x_1^2 + 6*x_1*x_2 + x_2^2 + 4*x_1*x_3 + 7*x_3^2\n</code></pre>"},{"location":"api/#polyany.polynomial.Polynomial.shift","title":"shift","text":"<pre><code>shift(k: int = 1) -&gt; Polynomial\n</code></pre> <p>Shifts the polynomial variables.</p> <p>This method returns a new polynomial with its variables shifted. A positive shift adds extra variables (increasing all variable indices). A negative shift removes variables, but only if they are empty.</p> PARAMETER DESCRIPTION <code>k</code> <p>The shift count. If positive, adds <code>k</code> extra variables (increase the variable indices). If negative, remove the first <code>abs(k)</code> variables, but only if they are empty (all corresponding exponents are zero).</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A new polynomial with shifted variables.</p> RAISES DESCRIPTION <code>TypeError</code> <ul> <li>If <code>k</code> is not an int.</li> </ul> <code>ValueError</code> <ul> <li>If <code>k</code> is negative and the number of variables after shifting would be less than one.</li> <li>If any of the first <code>abs(k)</code> variables are not empty.</li> </ul> Notes <p>If <code>k</code> = 0 a copy of the polynomial is returned.</p> <p>The Python shift operators can be used as a syntactic sugar for this method. <code>poly &gt;&gt; 3</code> is equivalent to <code>poly.shift(3)</code>, and <code>poly &lt;&lt; 2</code> is equivalent to <code>poly.shift(-2)</code>.</p> <p>This method is reversible as long as both directions are valid.</p> <ul> <li> <p>The statement <code>poly.shift(k).shift(-k)</code> will return a polynomial equal to the original object <code>poly</code>.</p> </li> <li> <p>Likewise, if <code>poly.shift(-k)</code> is possible, then applying <code>shift(k)</code> after it will also return a copy of <code>poly</code>.</p> </li> </ul> <p>Examples:</p> <p>Adding extra variables (shift right), increases the variable indices.</p> <pre><code>&gt;&gt;&gt; poly = Polynomial.univariate([1, 2, 3])\n&gt;&gt;&gt; poly\n1 + 2*x_1 + 3*x_1^2\n&gt;&gt;&gt; poly.shift(2)\n1 + 2*x_3 + 3*x_3^2\n&gt;&gt;&gt; poly &gt;&gt; 2 # equivalent syntax\n1 + 2*x_3 + 3*x_3^2\n</code></pre> <p>Removing empty variables (shift left), decreases the variable indices.</p> <pre><code>&gt;&gt;&gt; poly = Polynomial([[0, 1], [0, 3], [0, 5]], [10, 20, 30])\n&gt;&gt;&gt; poly\n10*x_2 + 20*x_2^3 + 30*x_2^5\n&gt;&gt;&gt; poly.shift(-1)\n10*x_1 + 20*x_1^3 + 30*x_1^5\n&gt;&gt;&gt; poly &lt;&lt; 1 # equivalent syntax\n10*x_1 + 20*x_1^3 + 30*x_1^5\n</code></pre>"},{"location":"api/#polyany.polynomial.Polynomial.univariate","title":"univariate  <code>classmethod</code>","text":"<pre><code>univariate(coefficients: ArrayLike) -&gt; Polynomial\n</code></pre> <p>Creates a univariate polynomial from a coefficients vector</p> <p>This classmethod is a convenient shortcut to construct a univariate polynomial from a coefficients vector.</p> PARAMETER DESCRIPTION <code>coefficients</code> <p>The coefficients of the univariate polynomial, associated with increasing powers of the variable <code>x_1</code>.</p> <p> TYPE: <code>ArrayLike</code> </p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A univariate polynomial.</p> RAISES DESCRIPTION <code>ValueError</code> <ul> <li>If <code>coefficients</code> does not have exactly one dimension.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Polynomial.univariate([1, 2, -3, -4, 5])\n1 + 2*x_1 - 3*x_1^2 - 4*x_1^3 + 5*x_1^4\n</code></pre>"},{"location":"api/#polyany.polynomial.Polynomial.zeros","title":"zeros  <code>classmethod</code>","text":"<pre><code>zeros(n_vars: int) -&gt; Polynomial\n</code></pre> <p>Create a zero polynomial.</p> <p>Returns a polynomial with a single monomial (the constant 0) in <code>n_vars</code> variables.</p> PARAMETER DESCRIPTION <code>n_vars</code> <p>Number of variables in the polynomial.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Polynomial</code> <p>A zero polynomial.</p> RAISES DESCRIPTION <code>TypeError</code> <ul> <li>If <code>n_vars</code> is not an int.</li> </ul> <code>ValueError</code> <ul> <li>If <code>n_vars</code> is less than 1.</li> </ul> Notes <p>Primarily intended for internal use in specific cases.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; poly = Polynomial.zeros(3)\n&gt;&gt;&gt; poly\n0\n&gt;&gt;&gt; poly.exponents\narray([[0, 0, 0]])\n&gt;&gt;&gt; poly.coefficients\narray([0.])\n</code></pre>"},{"location":"api/#polyany.types","title":"types","text":""},{"location":"api/#polyany.types.Algebraic","title":"Algebraic  <code>module-attribute</code>","text":"<pre><code>Algebraic: TypeAlias = Scalar | Polynomial\n</code></pre> <p>An algebraic element that can be a scalar or a Polynomial.</p>"},{"location":"api/#polyany.types.Scalar","title":"Scalar  <code>module-attribute</code>","text":"<pre><code>Scalar: TypeAlias = int | float | integer | floating\n</code></pre> <p>A numeric scalar that can be a builtin numeric type or a NumPy scalar.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Documentation under construction</p>"},{"location":"getting_started/#creating-polynomials","title":"Creating polynomials","text":"<p>In PolyAny a polynomial can be created in many forms. The most flexible way is defining a matrix of <code>exponents</code> and a vector of <code>coefficients</code>.</p>"},{"location":"getting_started/#from-exponents-and-coefficients","title":"From exponents and coefficients","text":"<p>The <code>exponents</code> matrix contains the exponents of each monomial of the polynomial, and the <code>coefficients</code> vector contains the corresponding scalars multipliers.</p> Basic example <p>Consider the monomial \\(M(\\mathbf{x}) = 5\\,x_1^2\\,x_2\\,x_3^4\\,x_5\\), its exponents and coefficient are given by:</p> <pre><code>exponents = [[2, 1, 4, 0, 1]] #(1)!\ncoefficient = [5]\n</code></pre> <ol> <li>When declaring the exponents matrix, variables are ordered increasingly, i.e., \\([x_1,\\,x_2,\\,x_3,\\,\\dots,\\,x_n]\\).</li> </ol> <p>Note that the exponent matrix represents the complete monomial, meaning that it must include all variables, even those raised to the power of \\(0\\).</p> Example <p>If we want to represent a polynomial, we declare the exponents and coefficients of each monomial. Consider:</p> \\[ P(\\mathbf{x}) = 5\\,x_1^2\\,x_2\\,x_3^4\\,x_5 + 3\\,x_1\\,x_2 + 4\\,x_4^4\\,x_5^3 \\] <p>The monomials of \\(P(\\mathbf{x})\\) are:</p> <ul> <li>\\(M_1(\\mathbf{x}) = 3\\,x_1\\,x_2\\)</li> <li>\\(M_2(\\mathbf{x}) = 4\\,x_4^4\\,x_5^3\\)</li> <li>\\(M_3(\\mathbf{x}) = 5\\,x_1^2\\,x_2\\,x_3^4\\,x_5\\)</li> </ul> <p>To represent \\(P(\\mathbf{x})\\), we define:</p> <pre><code>exponents = [[1, 1, 0, 0, 0], [0, 0, 0, 4, 3], [2, 1, 4, 0, 1]]\ncoefficients = [3, 4, 5]\n</code></pre> <p>It is very important that the coefficients appear in the same order as their corresponding rows in the exponents matrix.</p> <p>To create a polynomial from an exponents matrix and a coefficients vector in PolyAny, use the following syntax:</p> <pre><code>from polyany import Polynomial\n\nexponents = [[0, 0, 0], [1, 0, 0], [0, 1, 0]] #(1)!\ncoefficients = [1, 2, 3] #(2)!\n\npoly = Polynomial(exponents, coefficients)\n</code></pre> <ol> <li>The exponents matrix can also be a nested tuples or a NumPy 2D array</li> <li>The coefficients vector can also be a tuple or a NumPy 1D array</li> </ol> <p>The code above creates the following multivariate polynomial:</p> \\[ P(\\mathbf{x}) = 1 + 2\\,x_1 + 3\\,x_2 \\]"},{"location":"getting_started/#univariate-polynomials","title":"Univariate Polynomials","text":"Univariate Polynomials <p>A univariate polynomial \\(P(x_1)\\) is a polynomial that depends on a single variable \\(x_1\\). An example of univariate polynomial is:</p> \\[ P(x_1) = 2 x_1^2 + 3 x_1 + 4 \\] <p>To create univariate polynomials, a simpler syntax can be used, it only requires a <code>coefficients</code> vector.</p> <pre><code>from polyany import Polynomial\n\ncoefficients = [1, 5, 8, 9]\nunivar_poly = Polynomial.univariate(coefficients)\n</code></pre> <p>The coefficients are related with power of the variable \\(x_1\\) in increasing degree. The code above creates the polynomial:</p> \\[ P(x_1) = 1 + 5\\,x_1 + 8\\,x_1^2 + 9\\,x_1^3 \\]"},{"location":"getting_started/#quadratic-forms","title":"Quadratic forms","text":"Quadratic forms <p>A quadratic form is a second-degree homogeneous multivariate polynomial. It can be represented using a symmetric matrix \\(A \\in \\mathbb{R}^{n \\times n}\\) as:</p> \\[ P(\\mathbf{x}) = \\sum_{i=1}^{n}\\sum_{j=1}^{n} a_{ij} x_i x_j = \\mathbf{x}^{\\top}A\\mathbf{x} \\] <p>For further reading, see Linear Algebra Done Right by Sheldon Axler</p> <p>To create a quadratic form a square matrix must be provided.</p> <pre><code>from polyany import Polynomial\n\nmatrix = [[1, 2], [2, 3]] #(1)!\nquadratic_form_poly = Polynomial.quadratic_form(matrix)\n</code></pre> <ol> <li>The input matrix can also be nested tuples or a NumPy 2D array</li> </ol> <p>The code above creates the polynomial:</p> \\[ P(\\mathbf{x}) = x_1^2 + 4\\,x_1\\,x_2 + 3\\,x_2^2 \\] <p>Non-symmetric matrices</p> <p>If the input matrix \\(A\\) is not symmetric, a warning is raised and it's symmetric part \\(A_{\\mathrm{sym}}\\) is used instead, where</p> \\[ A_{\\mathrm{sym}} = \\frac{1}{2} \\left( A + A^{\\top} \\right) \\] Example <p>Suppose the input matrix is:</p> \\[ A = \\begin{bmatrix}     1 &amp; 6 \\\\     0 &amp; 2 \\end{bmatrix} \\] <p>Its symmetric part is:</p> \\[ A_{\\mathrm{sym}} = \\begin{bmatrix}     1 &amp; 3 \\\\     3 &amp; 2 \\end{bmatrix} \\] <p>which corresponds to the polynomial:</p> \\[ P(\\mathbf{x}) = x_1^2 + 6\\,x_1\\,x_2 + 2\\,x_2^2 \\]"},{"location":"getting_started/#evaluating-polynomials","title":"Evaluating polynomials","text":"<p>Polynomials can be easily evaluated in PolyAny by treating the polynomial object as a callable function. The input argument (<code>point</code>) must be a vector with <code>n_vars</code> components.</p> <pre><code>&gt;&gt;&gt; poly = Polynomial.univariate([1, 2, 3])\n&gt;&gt;&gt; poly([2]) #(1)!\nnp.float64(17.0)\n</code></pre> <ol> <li>Even for univariate polynomials, <code>point</code> needs to be a list, tuple or NumPy 1D-array.</li> </ol> <p>For multivariate polynomials:</p> <pre><code>&gt;&gt;&gt; matrix = [[1, 2, 3],\n...           [2, 4, 5],\n...           [3, 5, 6]]\n&gt;&gt;&gt; poly = Polynomial.quadratic_form(matrix)\n&gt;&gt;&gt; poly([0, 0, 0])\nnp.float64(0.0)\n&gt;&gt;&gt; poly([1, 1, 1])\nnp.float64(31.0)\n</code></pre>"},{"location":"getting_started/#comparing-polynomials","title":"Comparing polynomials","text":"<p>In PolyAny, Polynomial objects support equality comparisons (<code>==</code>) with other polynomials, but do not support ordering comparisons (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>), which raises a <code>TypeError</code>.</p> <p>Two polynomials are considered equal if and only if they have:</p> <ul> <li> The same number of variables (<code>n_vars</code> attribute)</li> <li> The same total degree (<code>degree</code> attribute)</li> <li> The same coefficients (<code>coefficients</code> attribute)<sup>1</sup></li> </ul> <p>Comparison with other types (sequences, scalars, NumPy arrays) always returns <code>NotImplemented</code>.</p> Example <p>Internally, the polynomial object stores the coefficients and exponents in an ordered way, meaning that a polynomial is created regardless of the order of the input coefficients and exponents.</p> <pre><code>&gt;&gt;&gt; poly1 = Polynomial([[0, 0], [1, 0], [0, 1]], [1, 2, 3])\n&gt;&gt;&gt; poly2 = Polynomial([[0, 1], [0, 0], [1, 0]], [3, 1, 2])\n&gt;&gt;&gt; poly1 == poly2\nTrue\n</code></pre>"},{"location":"getting_started/#pruning","title":"Pruning","text":"<p>Pruning is the process of removing empty monomials of a polynomial. The <code>Polynomial</code> object stores the exponents and coefficients provided by the user in a ordered way.</p> <pre><code>&gt;&gt;&gt; poly = Polynomial([[0, 0], [0, 1], [1, 0], [1, 1]], [1, 0, 2, 0])\n&gt;&gt;&gt; poly.exponents\narray([[0, 0],\n       [1, 0],\n       [0, 1],\n       [1, 1]])\n&gt;&gt;&gt; poly.coefficients\narray([1., 2., 0., 0.])\n</code></pre> <p>When a polynomial is pruned, all empty monomials are removed, that is, the entries in <code>exponents</code> whose associated coefficients are  exactly zero, which have no effect on the polynomial behavior.</p> <p>To prune a polynomial, use the <code>prune</code> method:</p> <pre><code>&gt;&gt;&gt; pruned = poly.prune()\n&gt;&gt;&gt; pruned.exponents\narray([[0, 0],\n       [1, 0]])\n&gt;&gt;&gt; pruned.coefficients\narray([1., 2.])\n</code></pre> <p>The pruned polynomial retains only the first and second term, which are the non-empty monomials.</p>"},{"location":"getting_started/#addition-and-subtraction","title":"Addition and subtraction","text":"<p>In PolyAny, Polynomial objects can be added or subtracted with scalars<sup>2</sup> and other polynomials.</p> <pre><code>&gt;&gt;&gt; poly = Polynomial.univariate([1, -2, 3])\n&gt;&gt;&gt; poly\n1 - 2*x_1 + 3*x_1^2\n&gt;&gt;&gt; poly + 5\n6 - 2*x_1 + 3*x_1^2\n&gt;&gt;&gt; poly - 1\n-2*x_1 + 3*x_1^2\n</code></pre> <p>For addition/subtraction between polynomials:</p> <pre><code>&gt;&gt;&gt; another_poly = Polynomial([[0, 0], [1, 0], [0, 1], [1, 1]], [1, -2, 3, -4])\n&gt;&gt;&gt; another_poly\n1 - 2*x_1 + 3*x_2 - 4*x_1*x_2\n&gt;&gt;&gt; poly + another_poly\n2 - 4*x_1 + 3*x_2 + 3*x_1^2 - 4*x_1*x_2\n&gt;&gt;&gt; poly - another_poly\n-3*x_2 + 3*x_1^2 + 4*x_1*x_2\n</code></pre>"},{"location":"getting_started/#multiplication-and-division","title":"Multiplication and division","text":"<p>Polynomials can be multiplied with other polynomials and scalars<sup>2</sup>.</p> <pre><code>&gt;&gt;&gt; poly = Polynomial.univariate([10, -20, 5])\n&gt;&gt;&gt; poly\n10 - 20*x_1 + 5*x_1^2\n&gt;&gt;&gt; poly * 2\n20 - 40*x_1 + 10*x_1^2\n</code></pre> <p>Multiplying two polynomials:</p> <pre><code>&gt;&gt;&gt; poly1 = Polynomial.univariate([1, -2, 3])\n&gt;&gt;&gt; poly1\n1 - 2*x_1 + 3*x_1^2\n&gt;&gt;&gt; poly2 = Polynomial([[0, 0], [1, 1]], [3, 3])\n&gt;&gt;&gt; poly2\n3 + 3*x_1*x_2\n&gt;&gt;&gt; poly1 * poly2\n3 - 6*x_1 + 9*x_1^2 + 3*x_1*x_2 - 6*x_1^2*x_2 + 9*x_1^3*x_2\n</code></pre> <p>Division between polynomials</p> <p>Currently, division can only be performed between polynomials and scalars. In the future, it is possible that division between polynomials will be supported.</p> <p>Dividing a polynomial by a scalar:</p> <pre><code>&gt;&gt;&gt; poly = Polynomial.univariate([10, -20, 5])\n&gt;&gt;&gt; poly\n10 - 20*x_1 + 5*x_1^2\n&gt;&gt;&gt; poly / 5\n2 - 4*x_1 + x_1^2\n</code></pre>"},{"location":"getting_started/#partial-derivatives","title":"Partial derivatives","text":"<p>The partial derivatives of polynomials can be evaluated by using the <code>partial</code> method. Let's consider the polynomial:</p> \\[ P(\\mathbf{x}) = 10 + 2\\,x_1^2\\,x_2\\,x_3 + 5\\,x_1\\,x_2^3\\,x_3^2 \\] <p>This can be declared in PolyAny as:</p> <pre><code>&gt;&gt;&gt; poly = Polynomial([[0, 0, 0], [2, 1, 1], [1, 3, 2]], [10, 2, 5])\n</code></pre> <p>Their first partial derivatives are:</p> \\[ \\begin{cases} \\displaystyle\\frac{\\partial P(\\mathbf{x})}{\\partial x_1} = 4\\,x_1\\,x_2\\,x_3 + 5\\,x_2^3\\,x_3^2 \\\\[.5em] \\displaystyle\\frac{\\partial P(\\mathbf{x})}{\\partial x_2} = 2\\,x_1^2\\,x_3 + 15\\,x_1\\,x_2^2\\,x_3^2 \\\\[.5em] \\displaystyle\\frac{\\partial P(\\mathbf{x})}{\\partial x_3} = 2\\,x_1^2\\,x_2 + 10\\,x_1\\,x_2^3\\,x_3 \\end{cases} \\] <p>which can be obtained in PolyAny as:</p> <pre><code>&gt;&gt;&gt; poly.partial(0) #(1)!\n4*x_1*x_2*x_3 + 5*x_2^3*x_3^2\n&gt;&gt;&gt; poly.partial(1)\n2*x_1^2*x_3 + 15*x_1*x_2^2*x_3^2\n&gt;&gt;&gt; poly.partial(2)\n2*x_1^2*x_2 + 10*x_1*x_2^3*x_3\n</code></pre> <ol> <li>The method partial uses a zero-based index.</li> </ol> <ol> <li> <p>A comparison is made by using <code>np.allclose()</code>, which checks if two arrays are equal within a tolerance.\u00a0\u21a9</p> </li> <li> <p>Python builtins numeric types (<code>int</code>, <code>float</code>) and NumPy scalars. See <code>Scalar</code> \u21a9\u21a9</p> </li> </ol>"},{"location":"installation/","title":"PolyAny","text":""},{"location":"installation/#how-to-install","title":"How to install","text":"<p>Using <code>uv</code>:</p> <pre><code>$ uv pip install polyany\n</code></pre> <p>To install uv, follow the instructions in the official documentation.</p> <p>Using pip:</p> <pre><code>$ pip install polyany\n</code></pre>"},{"location":"installation/#how-to-contribute","title":"How to contribute","text":"<p>This project uses <code>uv</code> to manage dependencies and environments.</p> <ol> <li> <p>Clone the repository</p> <pre><code>$ git clone https://github.com/rolmip/polyany.git\n$ cd polyany\n</code></pre> </li> <li> <p>Sync the uv environment</p> <pre><code>$ uv sync --all-groups\n</code></pre> </li> <li> <p>Activate the virtual environment</p> POSIXWindows cmdWindows PowerShell <pre><code>$ source .venv/bin/activate\n</code></pre> <pre><code>C:\\&gt; .venv\\Scripts\\activate.bat\n</code></pre> <pre><code>PS C:\\&gt; .venv\\Scripts\\Activate.ps1\n</code></pre> </li> <li> <p>Install git hooks</p> <pre><code>$ pre-commit install\n</code></pre> </li> </ol>"},{"location":"installation/#running-tests","title":"Running tests","text":"<p>To run all tests, just use:</p> <pre><code>$ uv run pytest\n</code></pre> <p>To run all tests with coverage analysis:</p> <pre><code>$ uv run pytest --cov --cov-branch\n</code></pre>"}]}